function [Fbest, BestChart] = LAEFA(fhd, N, D, max_it, max_fe, ElitistCheck, ...
    min_flag, Rpower, P_index, limit, p, k, alpha, K0)

%% LAEFA: elf-adaptive and locally-guided artificial electric field algorithm for global optimization with aggregative learning
%
% Authors: Dikshit Chauhan, Shivnai
% Reference:
% Chauhan, Dikshit, Shivani. "Self-adaptive and locally-guided artificial electric field algorithm for global optimization with aggregative learning."
% Knowledge-Based Systems (2025): 113835.
% DOI: https://doi.org/10.1016/j.knosys.2025.113835
%
% Inputs
%   fhd           : function handle, called as feval(fhd, X', P_index)
%   N, D          : population size, dimension
%   max_it        : maximum iterations (hard cap for arrays/visualization)
%   max_fe        : maximum function evaluations
%   ElitistCheck  : passed to Agg_Gfield
%   min_flag      : 1 for minimization, else maximization
%   Rpower        : passed to Agg_Gfield
%   P_index       : function index / parameter passed to fhd
%   limit,p,k,alpha,K0 : parameters passed to Agg_Gconstant / Agg_Gfield
%   dataVis       : 1 to plot diagnostics (2D only), else 0
%
% Outputs
%   Fbest     : best objective value found
%   BestChart : best-so-far curve (length = executed iterations)
%   Div       : diversity curve (length = executed iterations)
%
% Dependencies (must exist on your path)
%   initialization.m
%   Agg_massCalculation.m
%   Agg_Gconstant.m
%   Agg_Gfield.m
%   Agg_move.m
%   Requires Statistics and Machine Learning Toolbox for pdist/squareform
%
% Example
%   [Fbest, BestChart, Div] = LAEFA(@cec17_func, 50, 30, 500, 50*500, ...
%                                  1, 1, 1, 1, 10, 5, 1, 0.5, 1, 0);

% -------------------- Settings --------------------
Rnorm  = 2;
range  = [-100, 100];
down   = range(1);
up     = range(2);

varmax = up   * ones(1, D);
varmin = down * ones(1, D);

limvel = 0.1;
velmax = limvel * (varmax - varmin);
velmin = -velmax;

% Max distance in search space (used by Agg_Gfield)
r_max = sqrt(sum((varmax - varmin).^2));

% -------------------- Initialization --------------------
X = initialization(D, N, up, down);
V = initialization(D, N, velmax, velmin);

BestChart      = [];
history_fitness = zeros(1, N);
count_list     = zeros(1, N);
success_list   = zeros(1, N);

FES       = 0;
iteration = 0;
x_scale   = 0.7;


% -------------------- Main loop --------------------
while FES < max_fe
    iteration = iteration + 1;
    if iteration > max_it
        break; % safety guard
    end
    % Evaluate and sort
    fitness = feval(fhd, X', P_index);
    [fitness, sort_idx] = sort(fitness);
    X = X(sort_idx, :);

    % DE/current-to-pbest/1 is triggered for individuals whose fitness worsened
    X_new = X;
    fitness_new = fitness; % initialize

    for i = 1:N
        if history_fitness(i) < fitness(i)
            if N == 2*D
                a = 5; b = 10;
            else
                a = 5; b = 20;
            end

            pbest = round((b - a) * rand + a);

            r1 = randi(pbest);
            while r1 == i
                r1 = randi(pbest);
            end

            r2 = randi(N);
            while r2 == r1 || r2 == i
                r2 = randi(N);
            end

            r3 = randi(N);
            while r3 == r1 || r3 == r2 || r3 == i
                r3 = randi(N);
            end

            X_new(i,:) = X(i,:) + 0.9*(X(r1,:) - X(i,:)) + rand*(X(r2,:) - X(r3,:));
            fitness_new(i) = feval(fhd, X_new(i,:)', P_index);

            if fitness_new(i) < fitness(i)
                X(i,:) = X_new(i,:);
                fitness(i) = fitness_new(i);
            end
        end

    end

    % Fitness difference & counters
    if iteration == 1
        diff_fitness = zeros(1, N);
    else
        diff_fitness = history_fitness - fitness;
    end

    is_failed = diff_fitness < 0;
    for l = 1:N
        if is_failed(l)
            count_list(l)   = count_list(l) + 1;
            success_list(l) = 0;
        else
            count_list(l)   = 0;
            success_list(l) = success_list(l) + 1;
        end
    end

    % Best / worst
    if min_flag == 1
        [best, best_X]   = min(fitness);
        [~, worst_X]     = max(fitness);
    else
        [best, best_X]   = max(fitness);
        [~, worst_X]     = min(fitness);
    end

    if iteration == 1
        Fbest = best;
        Lbest = X(best_X,:);
    else
        if (min_flag == 1 && best < Fbest) || (min_flag ~= 1 && best > Fbest)
            Fbest = best;
            Lbest = X(best_X,:);
        end
    end

    % Distance index construction
    Dist = squareform(pdist(X));
    dis  = zeros(N, 3); % [distanceIndex, dummy, idx]
    for i = 1:N
        best_dis  = norm(X(i,:) - Lbest, Rnorm);
        worst_dis = norm(X(i,:) - X(worst_X,:), Rnorm);
        dis(i,1)  = best_dis + eps/(worst_dis + eps);
        dis(i,3)  = i;


        [~, neighbors] = sort(Dist(i,:));
    end

    dis_sort = sortrows(dis, 1);

    dis_sum = 0;
    for i = 2:N-1
        dis_sum = dis_sum + dis_sort(i,1);
    end
    diskbestnow2 = dis_sort(N-1,1) / dis_sum;

    BestChart = [BestChart; Fbest];

    % Mass & constants
    Q  = charge(fitness, min_flag);

    [G, count_list, success_list, ~, ~] = Kconstant( ...
        iteration, max_it, N, count_list, success_list, limit, p, a, alpha, K0);


    % Fields & movement
    [a1, a2, a3] = Efield(Q, X, G, Rnorm, Rpower, ElitistCheck, ...
        iteration, max_it, dis_sort, diskbestnow2, neighbors, r_max, k);

    [X, V, ~, ~, ~, ~] = Agg_move(X, a1, a2, a3, V, Lbest, iteration, ...
        max_it, dis_sort, varmin, varmax, velmin, velmax);

    % Updates
    FES = FES + N;
    history_fitness = fitness;
end
end


